"""
Web Exploitation Module
Exploits web vulnerabilities (default creds, CVEs, web shells)
"""

import requests
from typing import Dict, Tuple, Optional, List
from urllib.parse import urljoin

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from exploits.exploit_manager import BaseExploit
from utils.logger import logger


class WebExploit(BaseExploit):
    """Web application exploitation"""
    
    def __init__(self):
        super().__init__(
            name="Web_Exploit",
            target_ports=[80, 443, 8080, 8443],
            target_os=["Windows", "Linux", "Unknown"]
        )
        self.timeout = 5
    
    def check_vulnerable(self, target: Dict) -> bool:
        """Check if web server is accessible"""
        open_ports = target.get('open_ports', [])
        return any(port in open_ports for port in self.target_ports)
    
    def exploit(self, target: Dict) -> Tuple[bool, Optional[Dict]]:
        """
        Attempt web exploitation
        
        Tries multiple attack vectors:
        - Default credentials
        - Common admin panels
        - Known CVEs
        - File upload vulnerabilities
        """
        ip = target['ip']
        
        logger.info(f"Web: Attempting exploitation of {ip}")
        
        # Determine protocol and port
        protocol, port = self._get_web_endpoint(target)
        base_url = f"{protocol}://{ip}:{port}"
        
        # Try default credentials on common admin panels
        success, result = self._try_default_credentials(base_url)
        if success:
            return True, result
        
        # Try common vulnerabilities
        success, result = self._try_common_vulns(base_url)
        if success:
            return True, result
        
        # Try file upload
        success, result = self._try_file_upload(base_url)
        if success:
            return True, result
        
        return False, {'reason': 'no_vulnerabilities_found'}
    
    def _get_web_endpoint(self, target: Dict) -> Tuple[str, int]:
        """Determine web protocol and port"""
        open_ports = target.get('open_ports', [])
        
        if 443 in open_ports:
            return "https", 443
        elif 8443 in open_ports:
            return "https", 8443
        elif 80 in open_ports:
            return "http", 80
        elif 8080 in open_ports:
            return "http", 8080
        else:
            return "http", 80
    
    def _try_default_credentials(self, base_url: str) -> Tuple[bool, Optional[Dict]]:
        """Try default credentials on admin panels"""
        admin_paths = [
            '/admin',
            '/administrator',
            '/login',
            '/wp-admin',
            '/phpmyadmin',
            '/manager/html',  # Tomcat
            '/admin/login',
        ]
        
        credentials = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('administrator', 'administrator'),
            ('root', 'root'),
        ]
        
        for path in admin_paths:
            url = urljoin(base_url, path)
            
            try:
                # Check if path exists
                response = requests.get(url, timeout=self.timeout, verify=False, allow_redirects=True)
                
                if response.status_code == 200:
                    logger.debug(f"Web: Found admin panel at {url}")
                    
                    # Try credentials
                    for username, password in credentials:
                        if self._try_login(url, username, password):
                            logger.success(f"Web: Valid credentials - {username}:{password}")
                            
                            result = {
                                'method': 'Default_Credentials',
                                'url': url,
                                'username': username,
                                'password': password,
                                'access_level': 'Admin'
                            }
                            
                            return True, result
            
            except requests.exceptions.RequestException:
                continue
        
        return False, None
    
    def _try_login(self, url: str, username: str, password: str) -> bool:
        """
        Try login with credentials
        
        Real implementation would:
        - Detect login form
        - Submit credentials
        - Check for successful login
        """
        # Simulate login attempt
        import random
        return random.random() < 0.1  # 10% success rate
    
    def _try_common_vulns(self, base_url: str) -> Tuple[bool, Optional[Dict]]:
        """
        Try common web vulnerabilities
        
        Real implementation would check for:
        - SQL injection
        - Command injection
        - Path traversal
        - XXE
        - SSRF
        """
        logger.debug(f"Web: Checking common vulnerabilities on {base_url}")
        
        # Simulate vulnerability check
        import random
        if random.random() < 0.15:  # 15% success rate
            result = {
                'method': 'SQL_Injection',
                'url': base_url,
                'vulnerability': 'SQLi',
                'access_level': 'Database'
            }
            return True, result
        
        return False, None
    
    def _try_file_upload(self, base_url: str) -> Tuple[bool, Optional[Dict]]:
        """
        Try file upload vulnerability
        
        Real implementation would:
        - Find upload endpoints
        - Upload web shell
        - Execute commands
        """
        logger.debug(f"Web: Checking file upload on {base_url}")
        
        # Simulate file upload
        import random
        if random.random() < 0.1:  # 10% success rate
            result = {
                'method': 'File_Upload',
                'url': base_url,
                'shell_url': f"{base_url}/uploads/shell.php",
                'access_level': 'WebShell'
            }
            return True, result
        
        return False, None


class WebShellExploit(BaseExploit):
    """Deploy and use web shells"""
    
    def __init__(self):
        super().__init__(
            name="WebShell_Deploy",
            target_ports=[80, 443, 8080, 8443],
            target_os=["Windows", "Linux", "Unknown"]
        )
    
    def check_vulnerable(self, target: Dict) -> bool:
        """Check if web server allows file uploads"""
        # Would check for upload functionality
        return True
    
    def exploit(self, target: Dict) -> Tuple[bool, Optional[Dict]]:
        """
        Deploy web shell
        
        Real implementation would:
        - Upload PHP/ASPX web shell
        - Verify execution
        - Establish persistent access
        """
        ip = target['ip']
        
        logger.info(f"WebShell: Attempting deployment on {ip}")
        
        # Simulate web shell deployment
        import random
        success = random.random() < 0.2  # 20% success rate
        
        if success:
            result = {
                'method': 'WebShell',
                'shell_type': 'PHP',
                'shell_url': f"http://{ip}/uploads/shell.php",
                'access_level': 'WebShell',
                'commands_available': True
            }
            return True, result
        
        return False, {'reason': 'upload_failed'}


if __name__ == "__main__":
    # Test web exploit
    exploit = WebExploit()
    
    test_target = {
        'ip': '192.168.1.100',
        'open_ports': [80, 443],
        'os_guess': 'Linux',
        'banners': {80: 'Apache/2.4.41'},
        'vulnerability_score': 65
    }
    
    print(f"Testing {exploit.name}")
    print(f"Vulnerable: {exploit.check_vulnerable(test_target)}")
    
    # Disable SSL warnings for testing
    import urllib3
    urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
    
    success, result = exploit.exploit(test_target)
    print(f"Success: {success}")
    print(f"Result: {result}")
