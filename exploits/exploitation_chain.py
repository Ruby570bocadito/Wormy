"""
Exploitation Chain Engine
Automatically chains multiple exploits for maximum impact
"""

import sys
import os
from typing import Dict, List, Tuple
from datetime import datetime

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.logger import logger


class ExploitChain:
    """
    Represents a chain of exploits to be executed sequentially
    """
    
    def __init__(self, name: str):
        self.name = name
        self.steps = []
        self.success_rate = 0.0
        self.avg_time = 0.0
    
    def add_step(self, exploit_name: str, required: bool = True):
        """Add step to chain"""
        self.steps.append({
            'exploit': exploit_name,
            'required': required,
            'executed': False,
            'success': False
        })
    
    def get_next_step(self) -> Dict:
        """Get next unexecuted step"""
        for step in self.steps:
            if not step['executed']:
                return step
        return None


class ExploitationChainEngine:
    """
    Advanced exploitation using chained exploits
    """
    
    def __init__(self):
        self.chains = {}
        self.execution_history = []
        
        self._load_predefined_chains()
        logger.info("Exploitation Chain Engine initialized")
    
    def _load_predefined_chains(self):
        """Load predefined exploitation chains"""
        
        # Chain 1: Windows Domain Takeover
        domain_chain = ExploitChain("Windows_Domain_Takeover")
        domain_chain.add_step("SMB_Scan", required=True)
        domain_chain.add_step("SMB_Exploit", required=True)
        domain_chain.add_step("Privilege_Escalation", required=True)
        domain_chain.add_step("Credential_Dump", required=True)
        domain_chain.add_step("Lateral_Movement_DC", required=True)
        domain_chain.add_step("Domain_Admin_Compromise", required=True)
        self.chains["domain_takeover"] = domain_chain
        
        # Chain 2: Database Server Compromise
        db_chain = ExploitChain("Database_Server_Compromise")
        db_chain.add_step("Port_Scan_DB", required=True)
        db_chain.add_step("MySQL_Exploit", required=False)
        db_chain.add_step("PostgreSQL_Exploit", required=False)
        db_chain.add_step("MongoDB_Exploit", required=False)
        db_chain.add_step("Data_Exfiltration", required=True)
        db_chain.add_step("Backdoor_Installation", required=True)
        self.chains["database_compromise"] = db_chain
        
        # Chain 3: Web Server Takeover
        web_chain = ExploitChain("Web_Server_Takeover")
        web_chain.add_step("Web_Scan", required=True)
        web_chain.add_step("Web_Exploit", required=True)
        web_chain.add_step("Web_Shell_Upload", required=True)
        web_chain.add_step("Privilege_Escalation", required=True)
        web_chain.add_step("Persistence", required=True)
        self.chains["web_takeover"] = web_chain
        
        # Chain 4: Network Infrastructure
        network_chain = ExploitChain("Network_Infrastructure")
        network_chain.add_step("SNMP_Scan", required=True)
        network_chain.add_step("SNMP_Exploit", required=False)
        network_chain.add_step("Router_Compromise", required=False)
        network_chain.add_step("Network_Pivot", required=True)
        network_chain.add_step("Traffic_Interception", required=False)
        self.chains["network_infrastructure"] = network_chain
        
        # Chain 5: Complete Network Compromise
        complete_chain = ExploitChain("Complete_Network_Compromise")
        complete_chain.add_step("Initial_Foothold", required=True)
        complete_chain.add_step("Privilege_Escalation", required=True)
        complete_chain.add_step("Credential_Harvesting", required=True)
        complete_chain.add_step("Lateral_Movement", required=True)
        complete_chain.add_step("Domain_Compromise", required=False)
        complete_chain.add_step("Data_Exfiltration", required=True)
        complete_chain.add_step("Persistence_All_Hosts", required=True)
        complete_chain.add_step("Backdoor_Network", required=True)
        self.chains["complete_compromise"] = complete_chain
        
        logger.info(f"Loaded {len(self.chains)} predefined exploitation chains")
    
    def select_chain(self, target: Dict) -> str:
        """
        Automatically select best chain for target
        
        Args:
            target: Target information
        
        Returns:
            Chain name
        """
        # Analyze target
        open_ports = target.get('open_ports', [])
        os_type = target.get('os', '').lower()
        is_server = target.get('is_server', False)
        
        # Decision logic
        if 445 in open_ports and 'windows' in os_type:
            return "domain_takeover"
        
        elif any(port in open_ports for port in [3306, 5432, 27017]):
            return "database_compromise"
        
        elif any(port in open_ports for port in [80, 443, 8080]):
            return "web_takeover"
        
        elif 161 in open_ports:
            return "network_infrastructure"
        
        else:
            return "complete_compromise"
    
    def execute_chain(self, chain_name: str, target: Dict, exploit_manager) -> Tuple[bool, Dict]:
        """
        Execute exploitation chain
        
        Args:
            chain_name: Name of chain to execute
            target: Target information
            exploit_manager: Exploit manager instance
        
        Returns:
            (success, results)
        """
        if chain_name not in self.chains:
            logger.error(f"Chain not found: {chain_name}")
            return False, {}
        
        chain = self.chains[chain_name]
        logger.info(f"Executing chain: {chain.name} on {target['ip']}")
        
        results = {
            'chain_name': chain.name,
            'target': target['ip'],
            'start_time': datetime.now().isoformat(),
            'steps_executed': [],
            'steps_successful': [],
            'steps_failed': [],
            'overall_success': False
        }
        
        # Execute each step
        for step in chain.steps:
            step_name = step['exploit']
            logger.info(f"Executing step: {step_name}")
            
            step['executed'] = True
            
            # Simulate exploit execution
            # Real implementation would call actual exploits
            success = self._execute_step(step_name, target, exploit_manager)
            
            step['success'] = success
            results['steps_executed'].append(step_name)
            
            if success:
                results['steps_successful'].append(step_name)
                logger.success(f"Step successful: {step_name}")
            else:
                results['steps_failed'].append(step_name)
                logger.warning(f"Step failed: {step_name}")
                
                # If required step fails, abort chain
                if step['required']:
                    logger.error(f"Required step failed, aborting chain")
                    break
        
        # Calculate overall success
        required_steps = [s for s in chain.steps if s['required']]
        required_success = all(s['success'] for s in required_steps if s['executed'])
        
        results['overall_success'] = required_success
        results['end_time'] = datetime.now().isoformat()
        
        # Store in history
        self.execution_history.append(results)
        
        if required_success:
            logger.success(f"Chain completed successfully: {chain.name}")
        else:
            logger.warning(f"Chain failed: {chain.name}")
        
        return required_success, results
    
    def _execute_step(self, step_name: str, target: Dict, exploit_manager) -> bool:
        """Execute individual step"""
        # Map step names to actual exploits
        step_mapping = {
            'SMB_Scan': 'smb_scan',
            'SMB_Exploit': 'smb_exploit',
            'MySQL_Exploit': 'mysql_exploit',
            'PostgreSQL_Exploit': 'postgresql_exploit',
            'MongoDB_Exploit': 'mongodb_exploit',
            'Web_Scan': 'web_scan',
            'Web_Exploit': 'web_exploit',
            'SNMP_Scan': 'snmp_scan',
            'SNMP_Exploit': 'snmp_exploit',
        }
        
        # Simulate execution
        # Real implementation would call exploit_manager
        import random
        return random.random() > 0.3  # 70% success rate
    
    def get_chain_statistics(self) -> Dict:
        """Get statistics about chain executions"""
        if not self.execution_history:
            return {
                'total_executions': 0,
                'successful': 0,
                'failed': 0,
                'success_rate': 0.0
            }
        
        successful = sum(1 for r in self.execution_history if r['overall_success'])
        
        return {
            'total_executions': len(self.execution_history),
            'successful': successful,
            'failed': len(self.execution_history) - successful,
            'success_rate': successful / len(self.execution_history),
            'chains_used': list(set(r['chain_name'] for r in self.execution_history))
        }
    
    def create_custom_chain(self, name: str, steps: List[Tuple[str, bool]]) -> ExploitChain:
        """
        Create custom exploitation chain
        
        Args:
            name: Chain name
            steps: List of (exploit_name, required) tuples
        
        Returns:
            Created chain
        """
        chain = ExploitChain(name)
        
        for exploit_name, required in steps:
            chain.add_step(exploit_name, required)
        
        self.chains[name.lower().replace(' ', '_')] = chain
        logger.info(f"Created custom chain: {name} with {len(steps)} steps")
        
        return chain


if __name__ == "__main__":
    # Test exploitation chain engine
    engine = ExploitationChainEngine()
    
    print("="*60)
    print("EXPLOITATION CHAIN ENGINE TEST")
    print("="*60)
    
    # Test target
    test_target = {
        'ip': '192.168.1.100',
        'os': 'Windows Server 2019',
        'open_ports': [445, 3389, 80],
        'is_server': True
    }
    
    # Select chain
    chain_name = engine.select_chain(test_target)
    print(f"\nSelected Chain: {chain_name}")
    
    # Execute chain
    success, results = engine.execute_chain(chain_name, test_target, None)
    
    print(f"\nChain Execution Result: {'SUCCESS' if success else 'FAILED'}")
    print(f"Steps Executed: {len(results['steps_executed'])}")
    print(f"Steps Successful: {len(results['steps_successful'])}")
    print(f"Steps Failed: {len(results['steps_failed'])}")
    
    # Get statistics
    stats = engine.get_chain_statistics()
    print(f"\nChain Statistics:")
    print(f"  Total Executions: {stats['total_executions']}")
    print(f"  Success Rate: {stats['success_rate']:.1%}")
    
    # Create custom chain
    custom_steps = [
        ('Port_Scan', True),
        ('Exploit_Selection', True),
        ('Exploitation', True),
        ('Post_Exploitation', False)
    ]
    
    custom_chain = engine.create_custom_chain("My_Custom_Chain", custom_steps)
    print(f"\nCreated custom chain with {len(custom_chain.steps)} steps")
    
    print("="*60)
